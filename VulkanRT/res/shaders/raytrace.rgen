#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#include "raycommon.glsl"

// When tracing a ray, the hit or miss shaders need to be able to return some information to the shader
// program that invoked the ray tracing. This is done through the use of a payload (rayPayloadEXT).
layout(location = 0) rayPayloadEXT Payload payload;

// Input uniforms.
layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0) uniform Camera
{
  vec4 position;
  vec4 right;
  vec4 up;
  vec4 forward;
  vec4 lightPosition[32];

  uint frameCount;
} camera;

// Output image.
layout(binding = 4, set = 0, rgba32f) uniform image2D image;

layout(binding = 5) uniform sampler2D texSampler[72];

layout(binding = 6, set = 0) buffer ReservoirBuffer
{
    Reservoir data[];
} reservoirBuffer;

void main()
{
    // Start by computing the floating-point pixel coordinates of the current pixel being rendered.
    // gl_LaunchIDEXT contains the integer coords of the current pixel.
    // gl_LaunchSizeEXT contains the integer size of the image being rendered.
    vec2 uv = gl_LaunchIDEXT.xy + vec2(random(gl_LaunchIDEXT.xy, 0), random(gl_LaunchIDEXT.xy, 1));
    uv = uv / vec2(gl_LaunchSizeEXT.xy);
    uv = (uv * 2.0f - 1.0f) * vec2(1.0f, -1.0f); // Need to flip along Y-axis or image will be upside down

    payload.rayOrigin = camera.position.xyz;
    payload.rayDirection = normalize(uv.x * camera.right + uv.y * camera.up + camera.forward).xyz;
    payload.previousNormal = vec3(0.0, 0.0, 0.0);

    payload.directColor = vec3(0.0, 0.0, 0.0);
    payload.indirectColor = vec3(0.0, 0.0, 0.0);
    payload.rayDepth = 0;

    payload.rayActive = 1;

    // All geometry is opaque (i.e. no transparency)
    uint rayFlags = gl_RayFlagsOpaqueEXT;

    // Min and max of potential ray intersections.
    float tMin = 0.001;
    float tMax = 10000.0;

    // Perfrom multiple recursive ray traces for indirect lighting.
    uint recursionDepth = 2;
    for (int x = 0; x < recursionDepth; x++)
    {
        traceRayEXT(topLevelAS,             // Acceleration structure.
                    rayFlags,               // Flags.
                    0xFF,                   // Cull mask.
                    0,                      // Shader Binding Table hit group for offset.
                    0,                      // Shader Binding Table hit group for stride.
                    0,                      // Shader Binding Table miss shader index.
                    payload.rayOrigin,      // Ray origin.
                    tMin,                   // Ray min range.
                    payload.rayDirection,   // Ray direction.
                    tMax,                   // Ray max range.
                    0);                     // Payload (location = 0)
    }

    // Determine the final pixel color using the payload data.
    // directColor = texture color + lighting effects
    // indirectColor = multi-bounce lighting effects
    vec4 color = vec4(payload.directColor + payload.indirectColor, 1.0);

    // Temporal sampling of pixel color data.
    if (camera.frameCount > 0)
    {
        vec4 previousColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy));
        previousColor *= camera.frameCount;

        color += previousColor;
        color /= (camera.frameCount + 1);
    }

    // Finally, write the resulting payload into the output image for rendering.
    imageStore(image,                       // Handle to final image output.
               ivec2(gl_LaunchIDEXT.xy),    // Integer pixel location in final image.
               color);                      // Pixel color.
}